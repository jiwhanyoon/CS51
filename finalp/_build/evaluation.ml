(** A mini-ML
    @author Stuart M. Shieber

    This module implements a small untyped ML-like language under
    various operational semantics.
 *)

open Expr ;;
  
(* Exception for evaluator runtime generated by a runtime error *)
exception EvalError of string ;;
(* Exception for evaluator runtime generated by an explicit "raise" construct *)
exception EvalException ;;

module type Env_type = 
sig
    type env
    type value =
       | Val of expr
       | Closure of (expr * env)
    val create : unit -> env
    val close : expr -> env -> value
    val lookup : env -> varid -> value
    val extend : env -> varid -> value ref -> env
    val env_to_string : env -> string
    val value_to_string : ?printenvp:bool -> value -> string
  end

module Env : Env_type =
  struct

    type env = (varid * value ref) list
     and value =
       | Val of expr
       | Closure of (expr * env)

    exception EnvUnbound

    (* Creates an empty environment *)
    let create () : env = [] ;;

    (* Creates a closure from an expression and the environment it's
       defined in *)
    let close (exp: expr) (env: env) : value =
      Closure (exp , env)
      



    (* Looks up the value of a variable in the environment *)
    let lookup (env: env) (varname: varid) : value =
      (*find the variable that matches the varname from the environment *)
      let (variable, value) = 
        List.find (fun z -> match z with
                | (a, b) -> (a = varname)) env
      in 
      (*return the value of the valueref*)
      !value
      



    (* Returns a new environment just like env except that it maps the
       variable varid to loc *)
    let extend (env: env) (varname: varid) (loc: value ref) : env =
      (*return value is a list, so change the env to a list *)
      let env_to_list = List.remove_assoc varname env in 
      (varname, loc) :: env_to_list 
       




    (* Returns a printable string representation of an environment *)
    let rec env_to_string (env: env) : string =
    List.fold_right (fun (var,valref) acc ->  

    var  ^ ", " ^ (value_to_string !valref) ^  "," ^ acc) env ""

    (* Returns a printable string representation of a value; the flag
       printenvp determines whether to include the environment in the
       string representation when called on a closure *)
    and value_to_string ?(printenvp : bool = true) (v: value) : string =
      match v with
      | Val e -> "Exp : " ^ (exp_to_string e)
      | Closure (e, env) -> 
          if (printenvp = false)
          then "Exp : " ^ (exp_to_string e) ^ "; Env : [Not Included]"
          else
          "Exp : " ^ (exp_to_string e) ^ "; Env : [" ^ (env_to_string env) ^ "]"
  end
;;
	     
(* The evaluation function: Returns the result of type `value` of
   evaluating the expression `exp` in the environment `env`. In this
   initial implementation, we just convert the expression unchanged to
   a value and return it. *)
let evalunop e : expr = 
  match e with
    | Unop ("~", (Num x)) -> (Num (-x))
    | _ -> raise (EvalError "type error")

let evalbinop e : expr =
  match e with 
      | Binop ("+", (Num x),(Num y)) -> Num (x + y)
      | Binop ("*", (Num x),(Num y)) -> Num (x * y)
      | Binop ("-", (Num x),(Num y)) -> Num (x - y)
      | Binop ("=", (Num x),(Num y)) -> Bool (x = y)
      | Binop ("<", (Num x),(Num y)) -> Bool (x < y)
      | _ -> raise (EvalError "type error")

let eval_t exp _env = Env.Val exp ;;

let eval_s exp _env : Env.value = 
  let rec eval (e: expr) : expr =
    match e with
      | Var x -> Var x
      | Num x -> Num x
      | Bool b -> Bool b
      
      | Unop (v, e) -> evalunop (Unop (v, (eval e)))
      
      | Binop (v, e1, e2) -> evalbinop (Binop (v, (eval e1), (eval e2)))
      
      | Conditional (e1, e2, e3) -> 
        (match (eval e1) with 
              | Bool x -> if x then (eval e2) else (eval e3)
              | _ -> raise (EvalError "if statement is not a bool statement"))
      
      | Fun (x, e) -> Fun( x , e)
     
      | Let (x, e1, e2) -> (eval (subst x (eval e1) e2))

      | Letrec (x, e1, e2) -> 
          eval (subst x 
             (eval (subst x (Letrec (x,e1,(Var x))) e1))
                 e2)
      
      | Raise -> raise (EvalError "Error")
      | Unassigned -> raise (EvalError "Unassigned")
     
      | App (e1, e2) -> 
        (match (eval e1) with
                | Fun ( x, y ) -> (eval (subst x (eval e2) y))
                | _ -> raise (EvalError "this is not a function"))
  in
  Env.Val (eval exp)
 ;;

(*extracting the expression for different types of values *)
let extract (value: Env.value) : expr = 
  match value with
  | Env.Val (e) -> e
  | Env.Closure (e,env) -> e

let eval_d exp env : Env.value =
  let rec eval e env : expr = 
    match e with
    | Var x -> extract (Env.lookup env x)
    | Num _ -> exp
    | Bool _ -> exp
    
    | Unop (v, e) -> evalunop (Unop (v, (eval e env)))
    
    | Binop (v, e1, e2) -> evalbinop (Binop (v, (eval e1 env), (eval e2 env)))
    
    | Conditional (e1, e2, e3) -> 
      (match (eval e1 env) with 
            | Bool x -> if x then (eval e2 env) else (eval e3 env)
            | _ -> raise (EvalError "if statement is not a bool statement"))
    | Fun (x, e) -> Fun( x , e)




    | Let (x, e1, e2) -> 
        let e1' = (eval e1 env) in
        let env' = Env.extend env x (ref (Env.Val ( e1'))) in
          (eval e2 env')

    | Letrec (x, e1, e2) -> 
        let unassigned_ref = ref (Env.Val Unassigned) in 
        let env1' = (Env.extend env x unassigned_ref) in
        let e1' = (eval e1 env1') in
        unassigned_ref := Env.Val e1' ; 
        eval e2 env1'




    | Raise -> raise (EvalError "Error")
    | Unassigned -> Unassigned

    | App (e1, e2) -> 
      match (eval e1 env) with
      | Fun (x,y) -> 
        let a = (eval e2 env) in 
        let newenv = (Env.extend env x (ref (Env.Val (a)))) in
          eval y newenv;
      | _ -> raise (EvalError "Unbound")
  in
  Env.Val (eval exp env)
 ;;

let rec eval_l exp env =
match exp with 
| Var x -> Env.lookup env x
| Fun (v, e) -> Env.Closure (exp, env)
| App (p, q) ->
  (match eval_l p env with
  | Env.Closure(Fun(x, b), env2) ->
  let q_eval = eval_l q env2 in
  let new_env = Env.extend env2 x (ref q_eval) in 
  eval_l b new_env)
| Let (v,def,bod) -> 
      let def' = eval_l def env in 
      let env1 = Env.extend env v (ref ( def')) in 
        (eval_l bod env1) 
| Letrec (v,def,bod) -> 
    let unassig = ref (Env.Val Unassigned) in
    let envnew = Env.extend env v unassig in
    let q' = eval_l def envnew in 
    unassig := q' ; eval_l bod envnew; 
| _ -> eval_d exp env

(*
let rec eval_l exp env = 
  match exp with 
  | Var x -> (Env.lookup env x)
  | Fun (a, b) -> (Env.Closure (exp, env))
  
  | Let (v,e1,e2) -> 
   (     let e1' = (eval_l e1 env) in 
           let env' = (Env.extend env v (ref (e1'))) in 
             (eval_l e2 env') )
 

  | Letrec (v,e1,e2) -> 
(      let unassigned_ref = (ref (Env.Val (Unassigned))) in
      let env' = (Env.extend env v unassigned_ref) in
      (*similar to Let *)
      let e1' = (eval_l e1 env') in 
      unassigned_ref := e1' ; 
      eval_l e2 env'; )

  | App (e1, e2) ->
    (match (eval_l e1 env) with
      | Env.Closure (Fun (a, b), env') ->
          let e2' = (eval_l e2 env') in
          let env'' = (Env.extend env' a (ref (e2')) )in 
       (eval_l b env''))

  
  | _ -> eval_d exp env
 ;;

*)

let evaluate = eval_l ;;

